{
  "version": "1.0.0",
  "generated_at": "2026-01-20T19:45:00.000Z",
  "lessons": [
    {
      "iteration_id": "2026-01-20-007",
      "date": "2026-01-20",
      "goal": "Investigate high voice separation in wild zone",
      "type": "investigation",
      "result": "COMPLETED",
      "critical_finding": "Design misalignment + statistical artifact from sparse patterns",
      "what_was_discovered": "Voice separation is high (0.92) because: 1) COMPLEMENT design places shimmer in anchor's GAPS (preventing overlap by design), 2) Sparse MINIMAL-zone patterns inflate the average (voiceSep=1.0 when 4 hits can't overlap)",
      "root_cause_chain": [
        "1. COMPLEMENT relationship: shimmer fills GAPS in anchor (spec section 7)",
        "2. Gap-filling prevents overlap regardless of SHAPE or DRIFT",
        "3. DRIFT only varies WHERE in gap, not WHETHER to overlap",
        "4. MINIMAL zone (ENERGY=0.10) has 4 total hits → no overlap possible → voiceSep=1.0",
        "5. Averaging across ENERGY levels inflates wild zone metric"
      ],
      "key_insight": "The eval targets assume wild zone should have 32-68% voice overlap for 'power', but the COMPLEMENT spec designs for gap-filling (HIGH separation). Both syncopation (006) and voice separation (007) have targets that don't match spec design intent.",
      "why_lever_changes_wont_work": "No config lever can change the COMPLEMENT relationship. DRIFT varies placement within gaps but doesn't create overlap. Testing showed DRIFT 0→1 only changes voiceSep by 4% (0.85→0.89).",
      "statistical_artifact": {
        "description": "Sparse patterns at low ENERGY inflate voiceSeparation average",
        "example": "ENERGY=0.10 + SHAPE=0.85: 4 total hits (V1:2, V2:2, Aux:0) on different steps → voiceSep=1.0",
        "impact": "Wild zone average is 0.92, but at ENERGY>0.35 it's 0.82-0.87"
      },
      "recommended_actions": [
        "Revise voiceSeparation targets to match COMPLEMENT design: stable 0.75-0.95, syncopated 0.70-0.92, wild 0.65-0.95",
        "Consider making targets ENERGY-dependent since sparse patterns inflate metric",
        "Combine with syncopation target revision from iteration 006"
      ],
      "files_examined": [
        "tools/evals/evaluate-expressiveness.js:197-208 (voiceSeparation calculation)",
        "tools/evals/evaluate-expressiveness.js:58-62 (target ranges)",
        "docs/specs/main.md:434-466 (COMPLEMENT gap-filling design)",
        "tools/evals/public/data/energy-zone-metrics.json (ENERGY=0.10 → voiceSep=1.0)"
      ],
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-20-007.md",
        "full_log": "docs/design/iterations/2026-01-20-007.md"
      }
    },
    {
      "iteration_id": "2026-01-20-006",
      "date": "2026-01-20",
      "goal": "Investigate high syncopation in syncopated zone",
      "type": "investigation",
      "result": "COMPLETED",
      "critical_finding": "Design misalignment between algorithm intent and eval targets",
      "what_was_discovered": "The syncopation algorithm is DESIGNED to produce maximum syncopation (1.0) by placing hits on weak 16th notes. The eval targets expect moderate syncopation (0.22-0.48) for 'groove' feel. These are fundamentally misaligned.",
      "root_cause_chain": [
        "1. PatternField.cpp boosts weak offbeat weights (0.5-0.7) and suppresses downbeats",
        "2. HitBudget.cpp restricts eligibility to kSyncopationMask (only odd steps = weak 16ths)",
        "3. GumbelSampler selects from eligible positions with boosted weights",
        "4. Result: 10/12 hits land on weakest metric positions (weight 0.10)",
        "5. Syncopation metric calculates maximum tension (1.0)"
      ],
      "key_insight": "The syncopation ALGORITHM and syncopation METRIC both do what they're designed to do. The issue is that the EVAL TARGETS don't match the algorithm's design intent.",
      "recommended_actions": [
        "Option A: Revise eval target ranges to match algorithm behavior (syncopated: 0.70-1.00)",
        "Option B: Modify algorithm to produce MODERATE syncopation (mix strong/weak beats)",
        "Option C: Add syncopation intensity parameter for user control"
      ],
      "why_lever_changes_wont_work": "The syncopation algorithm's eligibility mask (kSyncopationMask) restricts sampling to only odd 16th-note positions. No lever change affects this mask - it's controlled by SHAPE threshold (>0.6). At SHAPE=0.5, the mask is active and hits MUST land on weak beats.",
      "files_examined": [
        "src/Engine/PatternField.cpp:58-117 (syncopation weight generation)",
        "src/Engine/HitBudget.cpp:279-337 (eligibility mask computation)",
        "src/Engine/GumbelSampler.cpp:169-207 (hit selection from eligible positions)",
        "src/Engine/PatternField.h:92-108 (design intent documentation)"
      ],
      "docs": {
        "full_log": "docs/design/iterations/2026-01-20-006.md"
      }
    },
    {
      "iteration_id": "2026-01-19-005",
      "date": "2026-01-20",
      "goal": "Decrease syncopation (auto-detected)",
      "lever_attempted": "kSyncopationWidth",
      "change": "0.30 → 0.20 (-33%)",
      "result": "FAILED",
      "prediction_accuracy": 0,
      "target_metric_delta": "0% (predicted -10% to -20%)",
      "critical_error": "Algorithm weight ≠ pattern characteristic",
      "what_went_wrong": "kSyncopationWidth controls algorithm blending, but syncopation METRIC measures pattern output. Changing algorithm weights doesn't directly change where hits land.",
      "key_insight": "Syncopation metric depends on HIT POSITIONS, not algorithm weights. A pattern generated with 100% euclidean can still be syncopated if hits land on weak beats.",
      "build_system_issue": {
        "description": "Makefile doesn't track algorithm_config.h dependencies",
        "symptom": "Changed header but binary wasn't rebuilt",
        "workaround": "Manually delete AlgorithmWeights.o to force rebuild",
        "fix_needed": "Add header dependencies to Makefile",
        "status": "FIXED",
        "fix_commit": "4d3983a"
      },
      "misconception_resolved": {
        "description": "Euclidean k vs HitBudget are separate concepts",
        "initial_observation": "At ENERGY=0.1, k=4 but only 2 anchor hits appear",
        "resolution": "NOT A BUG - HitBudget computes actual hits (2 at MINIMAL zone), k is just an algorithm parameter",
        "key_insight": "HitBudget.ComputeAnchorBudget() determines actual hit count, not euclidean k value"
      },
      "recommended_retry": {
        "approach": "Investigate WHY syncopation = 1.0 when eligibility already constrains to strong beats",
        "note": "MINIMAL zone eligibility already uses kDownbeatMask | kQuarterNoteMask (strong beats)",
        "investigation_needed": [
          "Check FLAVOR parameter in test fixtures (if > 0.6, adds syncopation mask)",
          "Check if syncopation is calculated on multi-voice combined pattern",
          "Verify test fixture ENERGY/SHAPE values match expected zone",
          "Add diagnostic trace for single pattern from generation through metric"
        ],
        "alternative_approaches": [
          "Increase MINIMAL zone hit budgets (more hits → more statistical coverage of strong beats)",
          "Revise syncopation target range if 0.00-0.22 is unachievable for sparse patterns"
        ]
      },
      "zone_terminology_note": {
        "description": "ENERGY zones and SHAPE zones are INDEPENDENT systems",
        "ENERGY_zones": "MINIMAL (0-0.20), GROOVE (0.20-0.50), BUILD (0.50-0.75), PEAK (0.75-1.0)",
        "SHAPE_zones": "stable (0.0-0.3), syncopated (0.3-0.7), wild (0.7-1.0) - used for metric TARGETS",
        "key_insight": "A pattern at ENERGY=0.1 (MINIMAL) can have any SHAPE value. Metric targets are SHAPE-zone-based, eligibility masks are ENERGY-zone-based."
      },
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-005.md",
        "full_log": "docs/design/iterations/2026-01-19-005.md"
      }
    },
    {
      "iteration_id": "2026-01-19-003",
      "date": "2026-01-20",
      "goal": "Improve regularity in stable zone",
      "lever_attempted": "kAnchorKMin",
      "change": "4 → 3 (-25%)",
      "result": "FAILED",
      "prediction_accuracy": 0,
      "target_metric_delta": "-1.2% (predicted +3-8%)",
      "critical_error": "Flawed hypothesis: sparser ≠ more regular",
      "what_went_wrong": "Hypothesis assumed sparser anchor patterns (fewer hits) would improve regularity. Reality: regularity measures gap uniformity, not sparseness. euclidean(16,4) has even 4-step gaps; euclidean(16,3) has uneven 5,5,6-step gaps.",
      "key_insight": "Regularity requires uniform gap spacing, not fewer hits. euclidean(n,k) where n/k is an integer produces most regular patterns. 16/4=4 is better than 16/3=5.33.",
      "regularity_theory": {
        "definition": "Gap uniformity between hits, not pattern sparseness",
        "optimal_k_values": "k values where n/k is an integer (for n=16: k=1,2,4,8,16)",
        "why_4_is_good": "euclidean(16,4) = gaps of [4,4,4,4] = perfectly uniform",
        "why_3_is_worse": "euclidean(16,3) = gaps of [5,5,6] or similar = non-uniform"
      },
      "recommended_retry": {
        "approach": "Investigate root cause of low stable zone regularity",
        "questions": [
          "Why is regularity 0.56 when euclidean(16,4) should be ~1.0?",
          "Is SHAPE varying within 'stable zone' test patterns?",
          "Are shimmer/aux patterns reducing overall regularity?"
        ],
        "confidence": "N/A (requires investigation, not lever change)"
      },
      "side_effects_discovered": {
        "voiceSeparation": "+4.8% (unexpected improvement)",
        "reason": "Sparser anchor created more gaps for shimmer to fill"
      },
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-003.md",
        "full_log": "docs/design/iterations/2026-01-19-003.md"
      }
    },
    {
      "iteration_id": "2026-01-19-002",
      "date": "2026-01-19",
      "goal": "Improve regularity in stable zone",
      "lever_attempted": "kEuclideanFadeEnd",
      "change": "0.70 → 0.77 (+10%)",
      "result": "FAILED",
      "prediction_accuracy": 14,
      "target_metric_delta": "+0.4% (predicted +10%)",
      "critical_error": "ENERGY vs SHAPE domain confusion",
      "what_went_wrong": "Lever operates on SHAPE parameter (0.70-0.77), but stable zone defined by ENERGY parameter (0.0-0.3). These don't overlap - low ENERGY patterns can have any SHAPE value.",
      "key_insight": "SHAPE levers don't affect ENERGY-defined zones. For zone-specific improvements, use levers that operate in the same parameter domain as the zone definition.",
      "parameter_domain_mapping": {
        "ENERGY_zones": {
          "stable": "0.0-0.3",
          "syncopated": "0.3-0.7",
          "wild": "0.7-1.0"
        },
        "SHAPE_levers": [
          "kEuclideanFadeStart",
          "kEuclideanFadeEnd",
          "kSyncopationCenter",
          "kSyncopationWidth",
          "kRandomFadeStart",
          "kRandomFadeEnd"
        ],
        "ENERGY_levers": [
          "kAnchorKMin",
          "kAnchorKMax",
          "kShimmerKMin",
          "kShimmerKMax",
          "kAuxKMin",
          "kAuxKMax"
        ]
      },
      "recommended_retry": {
        "lever": "kAnchorKMin or kAnchorKMax",
        "rationale": "These scale with ENERGY, directly affecting stable zone patterns",
        "confidence": "3/5 (untested hypothesis)"
      },
      "bootstrap_heuristic_updates": [
        {
          "metric": "regularity",
          "old_confidence": 4,
          "new_confidence": 2,
          "reason": "Failed iteration proved SHAPE levers don't affect ENERGY zones"
        }
      ],
      "calibration_lessons": [
        "Don't assume linear scaling (10% lever ≠ 10% metric, actual: 25x weaker)",
        "Sensitivity R²<0.5 indicates unreliable signal (70%+ unexplained variance)",
        "Bootstrap heuristics need empirical validation before trusting"
      ],
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-002.md",
        "full_log": "docs/design/iterations/2026-01-19-002.md",
        "pr": "https://github.com/chronick/duopulse/pull/4"
      }
    }
  ],
  "patterns": {
    "regularity_misconception": {
      "description": "Confusing pattern sparseness with regularity (gap uniformity)",
      "examples": [
        "2026-01-19-003: Assumed fewer hits = more regular"
      ],
      "prevention": "Remember: regularity = uniform gaps, not fewer hits",
      "checklist": [
        "Does changing this lever affect gap uniformity or hit count?",
        "For euclidean, check if n/k produces integer (uniform gaps)",
        "Test specific patterns to verify gap uniformity effect"
      ]
    },
    "zone_vs_parameter_confusion": {
      "description": "Attempting to improve a zone-specific metric with a lever that operates in a different parameter domain",
      "examples": [
        "2026-01-19-002: SHAPE lever for ENERGY zone"
      ],
      "prevention": "Always verify: lever operating range ∩ target zone parameter range ≠ ∅",
      "checklist": [
        "What parameter does the target zone use? (ENERGY, SHAPE, DRIFT, etc.)",
        "What parameter does the lever affect?",
        "Do these parameter spaces overlap?",
        "If not, find a lever in the correct domain"
      ]
    },
    "bootstrap_overconfidence": {
      "description": "Bootstrap heuristics with high confidence but low empirical validation",
      "examples": [
        "2026-01-19-002: 4/5 confidence, 14% actual accuracy"
      ],
      "prevention": "Downgrade confidence when sensitivity R²<0.5",
      "rule": "confidence = min(bootstrap_confidence, sensitivity_r_squared * 5)"
    },
    "algorithm_weight_vs_pattern_characteristic": {
      "description": "Assuming algorithm weight changes directly affect pattern metrics",
      "examples": [
        "2026-01-19-005: kSyncopationWidth change had 0% effect on syncopation metric"
      ],
      "prevention": "Verify the causal chain: lever → algorithm weight → hit positions → metric",
      "checklist": [
        "Does this lever change WHERE hits land, or just WHICH algorithm decides?",
        "Will the final pattern output actually change?",
        "Spot-check a single pattern before running full eval"
      ]
    },
    "euclidean_k_vs_hit_budget": {
      "description": "Debug shows euclidean k value, but actual hits come from HitBudget",
      "examples": [
        "2026-01-19-005: debug showed k=4 but only 2 hits - HitBudget was 2, not a bug"
      ],
      "status": "RESOLVED - understanding issue",
      "impact": "Misleading debug output can cause confusion",
      "prevention": [
        "Understand that euclidean k is algorithm parameter, not hit count",
        "Check HitBudget.ComputeAnchorBudget() for actual target hits",
        "Sparse patterns at MINIMAL zone are by design"
      ]
    },
    "sparse_pattern_statistical_artifacts": {
      "description": "Averaging metrics across ENERGY zones can be skewed by sparse MINIMAL-zone patterns",
      "examples": [
        "2026-01-20-007: voiceSep=1.0 at ENERGY=0.10 because 4 hits can't overlap"
      ],
      "prevention": "When analyzing zone averages, check if MINIMAL zone is inflating metrics",
      "checklist": [
        "Does the metric depend on overlap/collision that sparse patterns prevent?",
        "Check individual ENERGY levels, not just zone averages",
        "Consider ENERGY-dependent targets for metrics affected by density"
      ]
    },
    "eval_target_design_misalignment": {
      "description": "Eval targets set aspirationally rather than based on algorithm capabilities",
      "examples": [
        "2026-01-20-006: Syncopation targets expect 0.22-0.48, algorithm produces 0.95",
        "2026-01-20-007: VoiceSep targets expect 0.32-0.68, COMPLEMENT produces 0.92"
      ],
      "prevention": "Review spec design intent before accepting eval target failures",
      "checklist": [
        "Does the spec explain WHY the algorithm behaves this way?",
        "Is the target based on musical assumptions that contradict the spec?",
        "Could the target be revised rather than the algorithm?",
        "Run investigation iteration before attempting lever changes"
      ]
    }
  },
  "blockers": {
    "syncopation_target_misalignment": {
      "description": "Syncopated zone produces syncopation=0.95 but eval targets expect 0.22-0.48",
      "status": "DOCUMENTED",
      "iteration": "2026-01-20-006",
      "root_cause": "Algorithm designed for maximum displacement, targets expect moderate groove",
      "resolution_options": [
        "Revise eval targets to match algorithm (quick fix)",
        "Modify algorithm for moderate syncopation (better long-term)",
        "Add syncopation intensity parameter (most flexible)"
      ],
      "lever_changes_blocked": true,
      "reason": "No lever change can affect kSyncopationMask eligibility - it's hardcoded to odd 16th notes when SHAPE > 0.6"
    },
    "voice_separation_target_misalignment": {
      "description": "Wild zone produces voiceSeparation=0.92 but eval targets expect 0.32-0.68",
      "status": "DOCUMENTED",
      "iteration": "2026-01-20-007",
      "root_cause": "COMPLEMENT design places shimmer in anchor's gaps, preventing overlap by spec design",
      "resolution_options": [
        "Revise eval targets to match COMPLEMENT design (stable: 0.75-0.95, syncopated: 0.70-0.92, wild: 0.65-0.95)",
        "Make targets ENERGY-dependent (sparse patterns inflate metric)",
        "Accept high separation as a feature (clarity) not a bug"
      ],
      "lever_changes_blocked": true,
      "reason": "No config lever can change COMPLEMENT gap-filling behavior. DRIFT only varies placement within gaps (4% effect)."
    }
  }
}
