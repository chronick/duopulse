{
  "version": "1.0.0",
  "generated_at": "2026-01-19T00:30:00.000Z",
  "lessons": [
    {
      "iteration_id": "2026-01-19-005",
      "date": "2026-01-20",
      "goal": "Decrease syncopation (auto-detected)",
      "lever_attempted": "kSyncopationWidth",
      "change": "0.30 → 0.20 (-33%)",
      "result": "FAILED",
      "prediction_accuracy": 0,
      "target_metric_delta": "0% (predicted -10% to -20%)",
      "critical_error": "Algorithm weight ≠ pattern characteristic",
      "what_went_wrong": "kSyncopationWidth controls algorithm blending, but syncopation METRIC measures pattern output. Changing algorithm weights doesn't directly change where hits land.",
      "key_insight": "Syncopation metric depends on HIT POSITIONS, not algorithm weights. A pattern generated with 100% euclidean can still be syncopated if hits land on weak beats.",
      "build_system_issue": {
        "description": "Makefile doesn't track algorithm_config.h dependencies",
        "symptom": "Changed header but binary wasn't rebuilt",
        "workaround": "Manually delete AlgorithmWeights.o to force rebuild",
        "fix_needed": "Add header dependencies to Makefile",
        "status": "FIXED",
        "fix_commit": "4d3983a"
      },
      "misconception_resolved": {
        "description": "Euclidean k vs HitBudget are separate concepts",
        "initial_observation": "At ENERGY=0.1, k=4 but only 2 anchor hits appear",
        "resolution": "NOT A BUG - HitBudget computes actual hits (2 at MINIMAL zone), k is just an algorithm parameter",
        "key_insight": "HitBudget.ComputeAnchorBudget() determines actual hit count, not euclidean k value"
      },
      "recommended_retry": {
        "approach": "Investigate WHY syncopation = 1.0 when eligibility already constrains to strong beats",
        "note": "MINIMAL zone eligibility already uses kDownbeatMask | kQuarterNoteMask (strong beats)",
        "investigation_needed": [
          "Check FLAVOR parameter in test fixtures (if > 0.6, adds syncopation mask)",
          "Check if syncopation is calculated on multi-voice combined pattern",
          "Verify test fixture ENERGY/SHAPE values match expected zone",
          "Add diagnostic trace for single pattern from generation through metric"
        ],
        "alternative_approaches": [
          "Increase MINIMAL zone hit budgets (more hits → more statistical coverage of strong beats)",
          "Revise syncopation target range if 0.00-0.22 is unachievable for sparse patterns"
        ]
      },
      "zone_terminology_note": {
        "description": "ENERGY zones and SHAPE zones are INDEPENDENT systems",
        "ENERGY_zones": "MINIMAL (0-0.20), GROOVE (0.20-0.50), BUILD (0.50-0.75), PEAK (0.75-1.0)",
        "SHAPE_zones": "stable (0.0-0.3), syncopated (0.3-0.7), wild (0.7-1.0) - used for metric TARGETS",
        "key_insight": "A pattern at ENERGY=0.1 (MINIMAL) can have any SHAPE value. Metric targets are SHAPE-zone-based, eligibility masks are ENERGY-zone-based."
      },
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-005.md",
        "full_log": "docs/design/iterations/2026-01-19-005.md"
      }
    },
    {
      "iteration_id": "2026-01-19-003",
      "date": "2026-01-20",
      "goal": "Improve regularity in stable zone",
      "lever_attempted": "kAnchorKMin",
      "change": "4 → 3 (-25%)",
      "result": "FAILED",
      "prediction_accuracy": 0,
      "target_metric_delta": "-1.2% (predicted +3-8%)",
      "critical_error": "Flawed hypothesis: sparser ≠ more regular",
      "what_went_wrong": "Hypothesis assumed sparser anchor patterns (fewer hits) would improve regularity. Reality: regularity measures gap uniformity, not sparseness. euclidean(16,4) has even 4-step gaps; euclidean(16,3) has uneven 5,5,6-step gaps.",
      "key_insight": "Regularity requires uniform gap spacing, not fewer hits. euclidean(n,k) where n/k is an integer produces most regular patterns. 16/4=4 is better than 16/3=5.33.",
      "regularity_theory": {
        "definition": "Gap uniformity between hits, not pattern sparseness",
        "optimal_k_values": "k values where n/k is an integer (for n=16: k=1,2,4,8,16)",
        "why_4_is_good": "euclidean(16,4) = gaps of [4,4,4,4] = perfectly uniform",
        "why_3_is_worse": "euclidean(16,3) = gaps of [5,5,6] or similar = non-uniform"
      },
      "recommended_retry": {
        "approach": "Investigate root cause of low stable zone regularity",
        "questions": [
          "Why is regularity 0.56 when euclidean(16,4) should be ~1.0?",
          "Is SHAPE varying within 'stable zone' test patterns?",
          "Are shimmer/aux patterns reducing overall regularity?"
        ],
        "confidence": "N/A (requires investigation, not lever change)"
      },
      "side_effects_discovered": {
        "voiceSeparation": "+4.8% (unexpected improvement)",
        "reason": "Sparser anchor created more gaps for shimmer to fill"
      },
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-003.md",
        "full_log": "docs/design/iterations/2026-01-19-003.md"
      }
    },
    {
      "iteration_id": "2026-01-19-002",
      "date": "2026-01-19",
      "goal": "Improve regularity in stable zone",
      "lever_attempted": "kEuclideanFadeEnd",
      "change": "0.70 → 0.77 (+10%)",
      "result": "FAILED",
      "prediction_accuracy": 14,
      "target_metric_delta": "+0.4% (predicted +10%)",
      "critical_error": "ENERGY vs SHAPE domain confusion",
      "what_went_wrong": "Lever operates on SHAPE parameter (0.70-0.77), but stable zone defined by ENERGY parameter (0.0-0.3). These don't overlap - low ENERGY patterns can have any SHAPE value.",
      "key_insight": "SHAPE levers don't affect ENERGY-defined zones. For zone-specific improvements, use levers that operate in the same parameter domain as the zone definition.",
      "parameter_domain_mapping": {
        "ENERGY_zones": {
          "stable": "0.0-0.3",
          "syncopated": "0.3-0.7",
          "wild": "0.7-1.0"
        },
        "SHAPE_levers": [
          "kEuclideanFadeStart",
          "kEuclideanFadeEnd",
          "kSyncopationCenter",
          "kSyncopationWidth",
          "kRandomFadeStart",
          "kRandomFadeEnd"
        ],
        "ENERGY_levers": [
          "kAnchorKMin",
          "kAnchorKMax",
          "kShimmerKMin",
          "kShimmerKMax",
          "kAuxKMin",
          "kAuxKMax"
        ]
      },
      "recommended_retry": {
        "lever": "kAnchorKMin or kAnchorKMax",
        "rationale": "These scale with ENERGY, directly affecting stable zone patterns",
        "confidence": "3/5 (untested hypothesis)"
      },
      "bootstrap_heuristic_updates": [
        {
          "metric": "regularity",
          "old_confidence": 4,
          "new_confidence": 2,
          "reason": "Failed iteration proved SHAPE levers don't affect ENERGY zones"
        }
      ],
      "calibration_lessons": [
        "Don't assume linear scaling (10% lever ≠ 10% metric, actual: 25x weaker)",
        "Sensitivity R²<0.5 indicates unreliable signal (70%+ unexplained variance)",
        "Bootstrap heuristics need empirical validation before trusting"
      ],
      "docs": {
        "estimate": "docs/design/iterations/estimate-2026-01-19-002.md",
        "full_log": "docs/design/iterations/2026-01-19-002.md",
        "pr": "https://github.com/chronick/duopulse/pull/4"
      }
    }
  ],
  "patterns": {
    "regularity_misconception": {
      "description": "Confusing pattern sparseness with regularity (gap uniformity)",
      "examples": [
        "2026-01-19-003: Assumed fewer hits = more regular"
      ],
      "prevention": "Remember: regularity = uniform gaps, not fewer hits",
      "checklist": [
        "Does changing this lever affect gap uniformity or hit count?",
        "For euclidean, check if n/k produces integer (uniform gaps)",
        "Test specific patterns to verify gap uniformity effect"
      ]
    },
    "zone_vs_parameter_confusion": {
      "description": "Attempting to improve a zone-specific metric with a lever that operates in a different parameter domain",
      "examples": [
        "2026-01-19-002: SHAPE lever for ENERGY zone"
      ],
      "prevention": "Always verify: lever operating range ∩ target zone parameter range ≠ ∅",
      "checklist": [
        "What parameter does the target zone use? (ENERGY, SHAPE, DRIFT, etc.)",
        "What parameter does the lever affect?",
        "Do these parameter spaces overlap?",
        "If not, find a lever in the correct domain"
      ]
    },
    "bootstrap_overconfidence": {
      "description": "Bootstrap heuristics with high confidence but low empirical validation",
      "examples": [
        "2026-01-19-002: 4/5 confidence, 14% actual accuracy"
      ],
      "prevention": "Downgrade confidence when sensitivity R²<0.5",
      "rule": "confidence = min(bootstrap_confidence, sensitivity_r_squared * 5)"
    },
    "algorithm_weight_vs_pattern_characteristic": {
      "description": "Assuming algorithm weight changes directly affect pattern metrics",
      "examples": [
        "2026-01-19-005: kSyncopationWidth change had 0% effect on syncopation metric"
      ],
      "prevention": "Verify the causal chain: lever → algorithm weight → hit positions → metric",
      "checklist": [
        "Does this lever change WHERE hits land, or just WHICH algorithm decides?",
        "Will the final pattern output actually change?",
        "Spot-check a single pattern before running full eval"
      ]
    },
    "euclidean_k_vs_hit_budget": {
      "description": "Debug shows euclidean k value, but actual hits come from HitBudget",
      "examples": [
        "2026-01-19-005: debug showed k=4 but only 2 hits - HitBudget was 2, not a bug"
      ],
      "status": "RESOLVED - understanding issue",
      "impact": "Misleading debug output can cause confusion",
      "prevention": [
        "Understand that euclidean k is algorithm parameter, not hit count",
        "Check HitBudget.ComputeAnchorBudget() for actual target hits",
        "Sparse patterns at MINIMAL zone are by design"
      ]
    }
  },
  "blockers": {
  }
}
