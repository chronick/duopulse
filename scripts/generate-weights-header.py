#!/usr/bin/env python3
"""
Generate C++ header from JSON weight configuration.

This script converts the JSON weight configuration into a C++ header file
with constexpr values for zero runtime overhead in firmware.

Usage:
    python scripts/generate-weights-header.py [config_path] [output_path]

If no arguments provided:
    config_path defaults to config/weights/baseline.json
    output_path defaults to inc/generated/weights_config.h
"""

import json
import sys
import os
from datetime import datetime

def generate_header(config_path: str, output_path: str) -> None:
    """Generate C++ header from JSON config."""

    with open(config_path, 'r') as f:
        config = json.load(f)

    version = config.get('version', 'unknown')
    name = config.get('name', 'unnamed')
    description = config.get('description', '')

    euclidean = config['euclidean']
    syncopation = config['syncopation']
    random = config['random']

    timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')

    header = f'''/**
 * Auto-generated algorithm weight configuration
 *
 * Generated from: {os.path.basename(config_path)}
 * Config version: {version}
 * Config name: {name}
 * Generated at: {timestamp}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Edit the JSON source and regenerate with:
 *   make weights-header CONFIG={config_path}
 *
 * {description}
 */

#pragma once

namespace WeightConfig {{

// =============================================================================
// Configuration Metadata
// =============================================================================

constexpr const char* kConfigVersion = "{version}";
constexpr const char* kConfigName = "{name}";

// =============================================================================
// Euclidean Influence Curve
// =============================================================================

/// SHAPE value where euclidean starts fading (0.0-1.0)
constexpr float kEuclideanFadeStart = {euclidean['fadeStart']}f;

/// SHAPE value where euclidean reaches zero (0.0-1.0)
constexpr float kEuclideanFadeEnd = {euclidean['fadeEnd']}f;

// =============================================================================
// Per-Channel Euclidean K Ranges
// =============================================================================

/// Anchor voice euclidean k range
constexpr int kAnchorKMin = {euclidean['anchor']['kMin']};
constexpr int kAnchorKMax = {euclidean['anchor']['kMax']};

/// Shimmer voice euclidean k range
constexpr int kShimmerKMin = {euclidean['shimmer']['kMin']};
constexpr int kShimmerKMax = {euclidean['shimmer']['kMax']};

/// Aux voice euclidean k range
constexpr int kAuxKMin = {euclidean['aux']['kMin']};
constexpr int kAuxKMax = {euclidean['aux']['kMax']};

// =============================================================================
// Syncopation Bell Curve
// =============================================================================

/// SHAPE value at peak syncopation (0.0-1.0)
constexpr float kSyncopationCenter = {syncopation['center']}f;

/// Bell curve width (standard deviation)
constexpr float kSyncopationWidth = {syncopation['width']}f;

// =============================================================================
// Random Influence Curve
// =============================================================================

/// SHAPE value where random starts appearing (0.0-1.0)
constexpr float kRandomFadeStart = {random['fadeStart']}f;

/// SHAPE value where random reaches full strength (0.0-1.0)
constexpr float kRandomFadeEnd = {random['fadeEnd']}f;

}} // namespace WeightConfig
'''

    # Ensure output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        f.write(header)

    print(f"Generated {output_path} from {config_path}")
    print(f"  Config: {name} v{version}")

def main():
    # Default paths
    config_path = 'config/weights/baseline.json'
    output_path = 'inc/generated/weights_config.h'

    # Override from command line
    if len(sys.argv) > 1:
        config_path = sys.argv[1]
    if len(sys.argv) > 2:
        output_path = sys.argv[2]

    if not os.path.exists(config_path):
        print(f"Error: Config file not found: {config_path}")
        sys.exit(1)

    generate_header(config_path, output_path)

if __name__ == '__main__':
    main()
