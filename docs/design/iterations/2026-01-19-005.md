---
iteration_id: 2026-01-19-005
goal: "Decrease syncopation (auto-detected - over-target in all zones)"
status: failed
started_at: 2026-01-20T03:00:00Z
completed_at: 2026-01-20T03:15:00Z
branch: feature/iterate-2026-01-19-005
commit: null
pr: null
estimate_accuracy: 0
---

# Iteration 2026-01-19-005: Decrease syncopation

## Goal

Decrease syncopation toward target ranges. Auto-detected goal based on:
- stable zone: 1.00 (target 0.00-0.22) - OVER by 0.78
- syncopated zone: 0.95 (target 0.22-0.48) - OVER by 0.47
- wild zone: 0.77 (target 0.42-0.75) - OVER by 0.02

## Baseline Metrics

| Zone | Syncopation | Target | Status |
|------|-------------|--------|--------|
| stable | 1.00 | 0.00-0.22 | OVER |
| syncopated | 0.95 | 0.22-0.48 | OVER |
| wild | 0.77 | 0.42-0.75 | OVER |

Overall alignment: 44.5%

## Lever Analysis

Selected lever: **kSyncopationWidth**
- Current: 0.30f
- Proposed: 0.20f (-33%)
- Rationale: Narrow syncopation bell curve to reduce syncopation algorithm contribution

No sensitivity data available for this lever (only PatternFieldConfig levers have sensitivity data).

## Estimates (from estimate-2026-01-19-005.md)

### Predicted Impact

- Syncopation: Expected -10% to -20% reduction
- Confidence: MEDIUM (60%)
- Secondary effects: regularity +5-10% (more euclidean influence)

## Implementation Issue

**Build system issue discovered**: The Makefile's dependency tracking didn't detect changes to `inc/algorithm_config.h`. Had to manually delete `build/test_app_Engine/AlgorithmWeights.o` to force recompilation.

This caused initial evaluation runs to use stale binary (showing width=0.30 instead of 0.20).

## Result Metrics

After confirming correct binary (width=0.20 verified via `--debug-weights`):

| Metric | Before | After | Delta |
|--------|--------|-------|-------|
| syncopation (total) | 0.9346 | 0.9346 | 0.0% |
| syncopation (stable) | 1.00 | 1.00 | 0.0% |
| syncopation (syncopated) | 0.95 | 0.95 | 0.0% |
| syncopation (wild) | 0.77 | 0.77 | 0.0% |
| overall alignment | 44.5% | 44.5% | 0.0% |

**No change detected.**

## Prediction Accuracy Analysis

| Aspect | Predicted | Actual | Accuracy |
|--------|-----------|--------|----------|
| Syncopation change | -10% to -20% | 0% | 0% |
| Regularity change | +5% to +10% | 0% | N/A |

**Overall Estimate Accuracy**: 0%

## Why This Failed

### Root Cause Analysis

1. **kSyncopationWidth affects algorithm blending, not pattern output directly**
   - The lever controls how much the syncopation *algorithm* contributes vs euclidean/random
   - But even with more euclidean weight, if the pattern still has hits on weak beats, syncopation metric stays high

2. **Syncopation metric measures pattern characteristics, not algorithm weights**
   - Syncopation = tension from weak-beat hits followed by strong-beat rests
   - A pattern can be generated with euclidean algorithm but still be syncopated

3. **Deeper issue: Patterns are sparse and land on weak beats**
   - At ENERGY=0.1, SHAPE=0.1 (stable zone), only 2-4 hits in 64 steps
   - Those hits land on weak metric positions (steps 10-11, 42-43)
   - This creates high syncopation regardless of algorithm weights

4. **Hit count is way below euclidean k values**
   - Debug shows k=4 for anchor at ENERGY=0.1
   - But actual pattern only has 2 anchor hits
   - Some other filtering or gating is reducing hit counts

### Discovery: Hit Budget vs Euclidean k (NOT A BUG)

**UPDATE**: Investigation revealed this is NOT a bug but a misunderstanding:

- **"Euclidean k=4"** = algorithm parameter for generating evenly-spaced positions
- **Actual hits** = `HitBudget.ComputeAnchorBudget()` = 2 at ENERGY=0.10

At ENERGY=0.10 (MINIMAL zone):
```
minHits = 1
typicalHits = patternLength / 16 = 32 / 16 = 2
zoneProgress = 0.10 / 0.20 = 0.5
hits = 1 + (2 - 1) * 0.5 = 1.5 ≈ 2
```

The hit budget is intentionally low in MINIMAL zone. The debug output showing "k=4" is misleading because k is an algorithm parameter, not the actual hit count.

**Implication**: The high syncopation at low ENERGY is because:
1. Only 2 anchor hits in 32 steps
2. Those 2 hits can land on ANY metric position (not forced to strong beats)
3. Random placement at 2 hits → high chance of syncopation

This is a tuning decision, not a bug. To reduce syncopation in stable zone:
- Option A: Increase MINIMAL zone hit budgets
- Option B: Constrain eligibility masks to strong beats only
- Option C: Accept that MINIMAL zone patterns are inherently syncopated due to sparseness

## Lessons Learned

### What We Got Wrong

1. **Assumed algorithm weight affects syncopation metric**
   - The metric measures pattern output, not algorithm influence
   - Changing weights doesn't guarantee pattern characteristic changes

2. **Didn't verify pattern output before running full eval**
   - Should have spot-checked a stable zone pattern first
   - Would have discovered the sparse pattern issue earlier

3. **Build system issue caused confusion**
   - Initial runs showed no change because binary wasn't rebuilt
   - Need to add header dependency tracking to Makefile

### Key Insights

1. **Euclidean k value ≠ actual hit count** (NOT A BUG)
   - At ENERGY=0.1, debug shows k=4 but only 2 hits appear
   - This is expected: k is algorithm parameter, HitBudget determines actual hits
   - HitBudget.ComputeAnchorBudget() at MINIMAL zone returns 2, not k=4

2. **Syncopation comes from hit placement, not algorithm choice**
   - Even euclidean patterns can be syncopated if hits land on weak beats
   - Algorithm weights change WHICH algorithm generates candidates, not WHERE final hits land
   - Eligibility masks already constrain MINIMAL zone to strong beats (downbeats + quarter notes)

3. **The lever was correct domain but wrong mechanism**
   - kSyncopationWidth is a SHAPE-domain lever
   - But syncopation metric isn't directly coupled to syncopation algorithm weight
   - Need to investigate WHY syncopation = 1.0 when eligibility already constrains to strong beats

### Implications for Future Iterations

1. **Investigate WHY syncopation = 1.0 when eligibility constrains to strong beats**
   - The eligibility mask for MINIMAL zone already uses kDownbeatMask | kQuarterNoteMask
   - These ARE strong metric positions - so why is syncopation still high?
   - Check: FLAVOR parameter, multi-voice metric calculation, test fixture parameters

2. **Makefile header dependencies now track correctly**
   - `algorithm_config.h` changes now trigger recompilation (commit 4d3983a)

3. **Understand the distinction between zones:**
   - ENERGY zones (MINIMAL, GROOVE, BUILD, PEAK): HitBudget and eligibility
   - SHAPE zones (stable, syncopated, wild): Metric targets in evaluation
   - These are INDEPENDENT - a pattern at ENERGY=0.1 can have any SHAPE

4. **Diagnostic trace recommended**
   - Add unit test tracing a single stable-zone pattern from generation through metric
   - This will reveal where syncopation values come from

## Narration

This iteration attempted to reduce the extremely high syncopation metrics (1.0 in stable zone!) by narrowing the syncopation algorithm's bell curve. The hypothesis was that reducing syncopation algorithm influence would produce more euclidean (regular) patterns.

The first challenge was a build system issue - changes to `algorithm_config.h` weren't triggering recompilation. After manually forcing a rebuild, we verified the change was applied (debug output showed width=0.20). This build issue has been fixed (commit 4d3983a).

However, the evaluation showed zero change in any metric. Investigation revealed the key insight: **algorithm weights affect WHICH algorithm generates candidates, not WHERE final hits land**. The syncopation METRIC measures tension from weak-beat hits, regardless of which algorithm produced those positions.

We also resolved a misconception: the apparent "hit count suppression" (debug showing k=4 but only 2 hits) is NOT a bug. Euclidean k is an algorithm parameter; actual hit count comes from HitBudget.ComputeAnchorBudget(), which correctly returns 2 for MINIMAL zone.

A deeper mystery remains: the eligibility mask for MINIMAL zone ALREADY constrains hits to strong beats (kDownbeatMask | kQuarterNoteMask). So WHY is syncopation = 1.0? This needs root cause investigation - possible culprits include FLAVOR parameter, multi-voice metric calculation, or test fixture parameters.

**Key takeaway**: Algorithm weight changes don't directly affect pattern metrics. The causal chain is: lever → algorithm → CANDIDATE positions → HitBudget → eligibility mask → final pattern → metric. Changing algorithm weights is too early in this chain to affect the final metric reliably.

## Follow-Up Tasks

1. ~~**Investigate hit count suppression**~~ ✅ RESOLVED - Not a bug, HitBudget is separate from euclidean k
2. ~~**Add Makefile header dependencies**~~ ✅ DONE (commit 4d3983a)
3. **Improve debug output clarity** - Show actual hit budget alongside euclidean k
4. **Future investigation** - WHY does syncopation = 1.0 when eligibility already constrains to strong beats?
   - Note: "constrain eligibility masks to strong beats" is ALREADY IMPLEMENTED for MINIMAL zone
   - Root cause investigation needed - check FLAVOR param, multi-voice metrics, test fixtures

## Build System Fix Applied

**Commit**: 4d3983a

Added header dependency tracking to host builds:
- `-MMD -MP` flags generate `.d` dependency files
- `TEST_APP_OBJS` dependencies now included
- Changes to `algorithm_config.h` now trigger recompilation

Tested and verified: touching `algorithm_config.h` now triggers recompilation of `AlgorithmWeights.o`.
