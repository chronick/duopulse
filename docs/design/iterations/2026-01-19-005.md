---
iteration_id: 2026-01-19-005
goal: "Decrease syncopation (auto-detected - over-target in all zones)"
status: failed
started_at: 2026-01-20T03:00:00Z
completed_at: 2026-01-20T03:15:00Z
branch: feature/iterate-2026-01-19-005
commit: null
pr: null
estimate_accuracy: 0
---

# Iteration 2026-01-19-005: Decrease syncopation

## Goal

Decrease syncopation toward target ranges. Auto-detected goal based on:
- stable zone: 1.00 (target 0.00-0.22) - OVER by 0.78
- syncopated zone: 0.95 (target 0.22-0.48) - OVER by 0.47
- wild zone: 0.77 (target 0.42-0.75) - OVER by 0.02

## Baseline Metrics

| Zone | Syncopation | Target | Status |
|------|-------------|--------|--------|
| stable | 1.00 | 0.00-0.22 | OVER |
| syncopated | 0.95 | 0.22-0.48 | OVER |
| wild | 0.77 | 0.42-0.75 | OVER |

Overall alignment: 44.5%

## Lever Analysis

Selected lever: **kSyncopationWidth**
- Current: 0.30f
- Proposed: 0.20f (-33%)
- Rationale: Narrow syncopation bell curve to reduce syncopation algorithm contribution

No sensitivity data available for this lever (only PatternFieldConfig levers have sensitivity data).

## Estimates (from estimate-2026-01-19-005.md)

### Predicted Impact

- Syncopation: Expected -10% to -20% reduction
- Confidence: MEDIUM (60%)
- Secondary effects: regularity +5-10% (more euclidean influence)

## Implementation Issue

**Build system issue discovered**: The Makefile's dependency tracking didn't detect changes to `inc/algorithm_config.h`. Had to manually delete `build/test_app_Engine/AlgorithmWeights.o` to force recompilation.

This caused initial evaluation runs to use stale binary (showing width=0.30 instead of 0.20).

## Result Metrics

After confirming correct binary (width=0.20 verified via `--debug-weights`):

| Metric | Before | After | Delta |
|--------|--------|-------|-------|
| syncopation (total) | 0.9346 | 0.9346 | 0.0% |
| syncopation (stable) | 1.00 | 1.00 | 0.0% |
| syncopation (syncopated) | 0.95 | 0.95 | 0.0% |
| syncopation (wild) | 0.77 | 0.77 | 0.0% |
| overall alignment | 44.5% | 44.5% | 0.0% |

**No change detected.**

## Prediction Accuracy Analysis

| Aspect | Predicted | Actual | Accuracy |
|--------|-----------|--------|----------|
| Syncopation change | -10% to -20% | 0% | 0% |
| Regularity change | +5% to +10% | 0% | N/A |

**Overall Estimate Accuracy**: 0%

## Why This Failed

### Root Cause Analysis

1. **kSyncopationWidth affects algorithm blending, not pattern output directly**
   - The lever controls how much the syncopation *algorithm* contributes vs euclidean/random
   - But even with more euclidean weight, if the pattern still has hits on weak beats, syncopation metric stays high

2. **Syncopation metric measures pattern characteristics, not algorithm weights**
   - Syncopation = tension from weak-beat hits followed by strong-beat rests
   - A pattern can be generated with euclidean algorithm but still be syncopated

3. **Deeper issue: Patterns are sparse and land on weak beats**
   - At ENERGY=0.1, SHAPE=0.1 (stable zone), only 2-4 hits in 64 steps
   - Those hits land on weak metric positions (steps 10-11, 42-43)
   - This creates high syncopation regardless of algorithm weights

4. **Hit count is way below euclidean k values**
   - Debug shows k=4 for anchor at ENERGY=0.1
   - But actual pattern only has 2 anchor hits
   - Some other filtering or gating is reducing hit counts

### Discovery: Hit Suppression Problem

The pattern generation is producing far fewer hits than the euclidean k values suggest:
- Expected: k=4 anchor hits
- Actual: 2 anchor hits

This suggests:
- Hit budget constraints
- Gating/filtering logic
- Pattern field suppression

The syncopation problem may be a symptom of this deeper hit count issue.

## Lessons Learned

### What We Got Wrong

1. **Assumed algorithm weight affects syncopation metric**
   - The metric measures pattern output, not algorithm influence
   - Changing weights doesn't guarantee pattern characteristic changes

2. **Didn't verify pattern output before running full eval**
   - Should have spot-checked a stable zone pattern first
   - Would have discovered the sparse pattern issue earlier

3. **Build system issue caused confusion**
   - Initial runs showed no change because binary wasn't rebuilt
   - Need to add header dependency tracking to Makefile

### Key Insights

1. **Pattern hit count doesn't match euclidean k values**
   - At ENERGY=0.1, k=4 should give 4 hits, but only 2 appear
   - This is a pattern generation bug, not a tuning issue

2. **Syncopation comes from hit placement, not algorithm choice**
   - Even euclidean patterns can be syncopated if k values result in weak-beat hits
   - Or if other processing shifts hits to weak positions

3. **The lever was correct domain but wrong mechanism**
   - kSyncopationWidth is a SHAPE-domain lever, which is correct
   - But syncopation metric isn't directly coupled to syncopation algorithm weight

### Implications for Future Iterations

1. **Don't iterate on syncopation until hit count issue is resolved**
   - This is a bug, not a tuning parameter

2. **Add Makefile header dependencies**
   - `algorithm_config.h` changes need to trigger recompilation

3. **Investigate hit suppression**
   - Why do patterns have fewer hits than euclidean k values?
   - This is blocking all metric improvements

4. **Create a test for pattern hit counts vs k values**
   - Unit test: at ENERGY=X, verify anchor hits >= kAnchorKMin

## Narration

This iteration attempted to reduce the extremely high syncopation metrics (1.0 in stable zone!) by narrowing the syncopation algorithm's bell curve. The hypothesis was that reducing syncopation algorithm influence would produce more euclidean (regular) patterns.

The first challenge was a build system issue - changes to `algorithm_config.h` weren't triggering recompilation. After manually forcing a rebuild, we verified the change was applied (debug output showed width=0.20).

However, the evaluation showed zero change in any metric. Investigation revealed the deeper issue: patterns are extremely sparse (2 hits in 64 steps at low ENERGY) and those few hits land on weak metric positions, creating high syncopation regardless of algorithm weights.

The real problem isn't algorithm blending - it's that patterns don't have enough hits, and the hits they do have are in the wrong places. This is likely a bug in hit budget, gating, or pattern field logic.

**Key takeaway**: Syncopation is a symptom, not the disease. The root cause is hit count suppression.

## Follow-Up Tasks

1. **Investigate hit count suppression** - Why does k=4 produce only 2 hits?
2. ~~**Add Makefile header dependencies** - Prevent build issues~~ âœ… DONE (commit c9b9561)
3. **Create hit count regression test** - Ensure k values produce expected hit counts
4. **Defer syncopation iteration** - Until hit count is fixed

## Build System Fix Applied

**Commit**: c9b9561

Added header dependency tracking to host builds:
- `-MMD -MP` flags generate `.d` dependency files
- `TEST_APP_OBJS` dependencies now included
- Changes to `algorithm_config.h` now trigger recompilation

Tested and verified: touching `algorithm_config.h` now triggers recompilation of `AlgorithmWeights.o`.
