---
iteration_id: 2026-01-20-006
goal: "Investigate high syncopation in syncopated zone"
type: investigation
status: completed
started_at: 2026-01-20T18:00:00Z
completed_at: 2026-01-20T18:45:00Z
branch: feature/iterate-2026-01-20-006
commit: pending
pr: pending
---

# Iteration 2026-01-20-006: Root Cause Investigation - High Syncopation

## Executive Summary

This iteration investigated why the syncopated zone produces syncopation values of 0.95 when the target range is 0.22-0.48. The investigation revealed that **this is a design issue, not a bug**.

The syncopation algorithm is intentionally designed to place hits on weak 16th note positions (metric weight 0.10) to create "funk-style displaced patterns with tension and forward motion." This creates **maximum possible syncopation** (1.0), not the moderate syncopation (0.22-0.48) expected for musical "syncopated grooves."

**Key Finding**: The target ranges for syncopation need to be revised to match the algorithm's actual design intent, OR the algorithm needs modification to produce moderate (not maximum) syncopation.

## Goal

Investigate why syncopation = 0.95 in syncopated zone when target is 0.22-0.48.

## Baseline Metrics

From `metrics/baseline.json` (v1.0.15):
- Syncopated zone syncopation: **0.95** (target: 0.22-0.48)
- Gap from target max: **+0.47** (97% over target maximum)
- Pentagon score: 41.2%
- Overall alignment: 58.7%

## Investigation Process

### Step 1: Check if FLAVOR parameter exists

**Finding**: No FLAVOR parameter is exposed in pattern_viz or generate-patterns.js. The iteration-lessons.json mention of FLAVOR was a hypothesis from prior investigation that was never implemented.

### Step 2: Analyze actual hit positions

Generated patterns at SHAPE=0.50 (syncopated zone center):

```
V1 Hit Positions: 0, 1, 7, 17, 23, 27, 32, 33, 39, 49, 55, 59

Position Analysis:
  Step  0: weight=1.00 (DOWNBEAT)
  Step  1: weight=0.10 (16TH - WEAK)
  Step  7: weight=0.10 (16TH - WEAK)
  Step 17: weight=0.10 (16TH - WEAK)
  Step 23: weight=0.10 (16TH - WEAK)
  Step 27: weight=0.10 (16TH - WEAK)
  Step 32: weight=1.00 (DOWNBEAT)
  Step 33: weight=0.10 (16TH - WEAK)
  Step 39: weight=0.10 (16TH - WEAK)
  Step 49: weight=0.10 (16TH - WEAK)
  Step 55: weight=0.10 (16TH - WEAK)
  Step 59: weight=0.10 (16TH - WEAK)

Result: 10/12 hits on weakest positions (weight 0.10)
        2/12 hits on downbeats (weight 1.00)
```

### Step 3: Compare with stable zone

```
STABLE ZONE (SHAPE=0.15):
  V1 positions: 0, 4, 10, 14, 20, 24, 30, 32, 36, 42, 46, 52, 56, 62
  Beat types: Downbeats, backbeats, 8th notes
  Syncopation: 0.0 (ALL hits on strong beats)

SYNCOPATED ZONE (SHAPE=0.50):
  V1 positions: 0, 1, 7, 17, 23, 27, 32, 33, 39, 49, 55, 59
  Beat types: 2 downbeats + 10 weak 16th notes
  Syncopation: 1.0 (maximum possible)
```

### Step 4: Trace the algorithm

**Algorithm weights at SHAPE=0.50:**
```
Euclidean:    33.3%
Syncopation:  66.7%  <-- DOMINATES
Random:       0.0%
```

**How syncopation algorithm places hits:**

1. **Weight Generation** (`PatternField.cpp:83-102`):
   - Downbeats SUPPRESSED to 50-70% of normal weight
   - Weak offbeats (odd steps) BOOSTED to 0.5-0.7 range

2. **Eligibility Mask** (`HitBudget.cpp:327-334`):
   ```cpp
   if (flavor > 0.6f) {
       eligibility |= kSyncopationMask;  // = 0xAAAA... (only odd steps!)
   }
   ```
   - When SHAPE > 0.6, sampling ONLY considers odd 16th note positions

3. **Gumbel Sampling** (`GumbelSampler.cpp:169-207`):
   - Computes score = log(weight) + noise for each eligible position
   - Selects top K scores
   - Because eligibility mask restricts to weak 16ths AND weights are boosted there, weak 16ths win

**Design Intent** (from `PatternField.h:92-108`):
```cpp
/**
 * Generate syncopation pattern weights
 *
 * Produces funk-style, displaced patterns with:
 * - Suppressed downbeats (beat 1 at 50-70% of normal weight)
 * - Boosted anticipation positions (step before downbeat)
 * - Boosted weak offbeats
 * - Creates tension and forward motion
 */
```

## Root Cause

**The syncopation algorithm is DESIGNED to produce maximum syncopation**, not moderate syncopation. It accomplishes this by:

1. Suppressing strong beats (downbeats, quarter notes)
2. Boosting weak beats (16th note offbeats)
3. Restricting eligibility to only weak positions

This creates "funk-style displaced patterns" with maximum "tension and forward motion" - which is the design intent. However, this results in syncopation = 1.0 (max), not the 0.22-0.48 range expected by the eval metrics.

## The Discrepancy

| Aspect | Algorithm Design | Eval Target |
|--------|------------------|-------------|
| Intent | Maximum displacement | Moderate groove |
| Syncopation | 1.0 | 0.22-0.48 |
| Beat placement | Almost all weak 16ths | Mix of strong and weak |

**The algorithm and the evaluation targets are misaligned.**

## Possible Solutions

### Option A: Revise Target Ranges (Quick Fix)

Update `evaluate-expressiveness.js` to match what the algorithm actually produces:

```javascript
syncopation: {
  targetByZone: {
    stable: '0.00-0.20',      // Low syncopation
    syncopated: '0.70-1.00',  // HIGH syncopation (algorithm design)
    wild: '0.60-1.00'         // Very high syncopation
  },
}
```

**Pros**: Quick, matches algorithm behavior
**Cons**: May not reflect musical expectations for "syncopated groove"

### Option B: Modify Algorithm (Better Long-Term)

Adjust syncopation algorithm to produce MODERATE syncopation:

1. **Reduce offbeat boosting**: Instead of 0.5-0.7, use 0.3-0.5 for weak offbeats
2. **Increase downbeat weight**: Keep some hits on strong beats
3. **Create a gradient**: Mix strong and weak beat placements

```cpp
// Example: More moderate syncopation weights
if (isWeakOffbeat) {
    // Moderate boost instead of aggressive boost
    weight = 0.35f + HashToFloat(seed, step + 200) * 0.15f;  // 0.35-0.50
}
else if (step % 4 == 0) {
    weight = 0.5f;  // Quarter notes: keep them viable
}
```

**Pros**: Creates musically-expected "groove" syncopation
**Cons**: Requires C++ changes, may affect other musical qualities

### Option C: Add Syncopation Intensity Parameter

Add a new control parameter for syncopation intensity:

```cpp
// 0.0 = minimal displacement, 1.0 = maximum displacement
float syncopationIntensity = 0.5f;  // New parameter

// Blend between euclidean (stable) and displaced (syncopated) positions
float offbeatBoost = syncopationIntensity * 0.3f;  // Scaled boost
```

**Pros**: User control over syncopation amount
**Cons**: More complexity, requires UI changes

## Recommendation

**Short-term**: Proceed with Option A (revise targets) to unblock other work.

**Long-term**: Implement Option B (modify algorithm) to produce musically-appropriate moderate syncopation. This aligns the algorithm with the musical expectation that "syncopated groove" means some displacement, not maximum displacement.

## Decision

This iteration is an **INVESTIGATION**, not a lever-change iteration. No algorithm changes were made.

**Next Steps**:
1. Create a new task to revise syncopation target ranges (Option A)
2. Create a future task to modify syncopation algorithm intensity (Option B)
3. Update iteration-lessons.json with these findings

## Lessons Learned

### Key Insight

The syncopation METRIC (measuring hit positions relative to beat structure) and the syncopation ALGORITHM (intentionally displacing hits to weak beats) are not the same thing.

- **Syncopation metric**: Measures how much hits deviate from strong beats
- **Syncopation algorithm**: Intentionally places hits on weak beats for "funk feel"

The algorithm is designed to maximize what the metric measures.

### Terminology Clarification

- "Syncopated zone" in evals refers to SHAPE 0.3-0.7 (metric target range)
- "Syncopation algorithm" refers to hit placement that creates displacement
- These are DIFFERENT concepts that happen to share a name

### Investigation Value

This investigation prevented another failed lever-change iteration. The root cause was not:
- FLAVOR parameter (doesn't exist)
- Algorithm weight misconfiguration (weights are correct)
- Eligibility mask bugs (masks work as designed)

The root cause is a **design misalignment** between algorithm intent and evaluation targets.

## Files Examined

| File | Lines | Finding |
|------|-------|---------|
| `src/Engine/PatternField.cpp` | 58-117 | Syncopation weights boost weak offbeats |
| `src/Engine/HitBudget.cpp` | 279-337 | kSyncopationMask = only odd steps |
| `src/Engine/GumbelSampler.cpp` | 169-207 | Selection from eligible positions |
| `src/Engine/PatternField.h` | 92-108 | Design intent documentation |
| `tools/evals/evaluate-expressiveness.js` | 40-44 | Target ranges for syncopation |
| `tools/evals/generate-patterns.js` | 244-253 | Test pattern parameters |

## Narration

This iteration started with auto-detection identifying the syncopated zone's syncopation (0.95) as the largest gap from target (0.22-0.48). Previous iterations had attempted lever changes (kSyncopationWidth) without success.

Rather than attempt another lever change, we investigated the root cause. The analysis revealed that the syncopation algorithm is **working exactly as designed** - it intentionally places hits on weak 16th note positions to create "funk-style displaced patterns with tension and forward motion."

The mismatch is between:
1. **Algorithm design**: Maximize displacement for funk feel (syncopation → 1.0)
2. **Eval targets**: Expect moderate displacement for groove (syncopation → 0.22-0.48)

This is a fundamental design question: Should the "syncopated zone" produce maximum syncopation (algorithm intent) or moderate syncopation (musical groove expectation)?

The recommendation is to revise the eval targets in the short term and consider algorithm modifications for better musical alignment in the long term.

This investigation prevented wasted effort on parameter tuning and identified the true nature of the issue as a design alignment question.
